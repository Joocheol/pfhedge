digraph "classes_pfhedge" {
rankdir=BT
charset="utf-8"
"pfhedge.instruments.derivative.american_binary.AmericanBinaryOption" [color="black", fontcolor="black", label=<{AmericanBinaryOption|call : bool<br ALIGN="LEFT"/>maturity : float<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>payoff_fn(): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.bs.american_binary.BSAmericanBinaryOption" [color="black", fontcolor="black", label=<{BSAmericanBinaryOption|call : bool<br ALIGN="LEFT"/>derivative : Optional[AmericanBinaryOption]<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>|delta(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>from_derivative(derivative)<br ALIGN="LEFT"/>gamma(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>implied_volatility(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], price: Optional[Tensor], precision: float): Tensor<br ALIGN="LEFT"/>price(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>theta(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>vega(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.bs.european_binary.BSEuropeanBinaryOption" [color="black", fontcolor="black", label=<{BSEuropeanBinaryOption|call : bool<br ALIGN="LEFT"/>derivative : Optional[EuropeanBinaryOption]<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>|delta(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>from_derivative(derivative)<br ALIGN="LEFT"/>gamma(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>implied_volatility(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], price: Optional[Tensor], precision: float): Tensor<br ALIGN="LEFT"/>inputs(): List[str]<br ALIGN="LEFT"/>price(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>theta(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>vega(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.bs.european.BSEuropeanOption" [color="black", fontcolor="black", label=<{BSEuropeanOption|call : bool<br ALIGN="LEFT"/>derivative : Optional[EuropeanOption]<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>|delta(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>from_derivative(derivative)<br ALIGN="LEFT"/>gamma(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>implied_volatility(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], price: Optional[Tensor], precision: float): Tensor<br ALIGN="LEFT"/>price(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>theta(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>vega(log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.bs.lookback.BSLookbackOption" [color="black", fontcolor="black", label=<{BSLookbackOption|call : bool<br ALIGN="LEFT"/>derivative : Optional[LookbackOption]<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>|delta(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor], create_graph: bool): Tensor<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>from_derivative(derivative)<br ALIGN="LEFT"/>gamma(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>implied_volatility(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], price: Optional[Tensor], precision: float): Tensor<br ALIGN="LEFT"/>inputs(): List[str]<br ALIGN="LEFT"/>price(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>theta(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>vega(log_moneyness: Optional[Tensor], max_log_moneyness: Optional[Tensor], time_to_maturity: Optional[Tensor], volatility: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.bs._base.BSModuleMixin" [color="black", fontcolor="black", label=<{BSModuleMixin|<br ALIGN="LEFT"/>|delta(): Tensor<br ALIGN="LEFT"/>forward(input: Tensor): Tensor<br ALIGN="LEFT"/>gamma(): Tensor<br ALIGN="LEFT"/>inputs(): List[str]<br ALIGN="LEFT"/><I>price</I>(): Tensor<br ALIGN="LEFT"/>theta(): Tensor<br ALIGN="LEFT"/>vega(): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.Barrier" [color="black", fontcolor="black", label=<{Barrier|threshold : float<br ALIGN="LEFT"/>up : bool<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.derivative.base.BaseDerivative" [color="black", fontcolor="black", label=<{BaseDerivative|cost : float<br ALIGN="LEFT"/>device<br ALIGN="LEFT"/>dtype<br ALIGN="LEFT"/>is_listed<br ALIGN="LEFT"/>maturity : float<br ALIGN="LEFT"/>pricer : Optional[Callable[[Any], Tensor]]<br ALIGN="LEFT"/>spot<br ALIGN="LEFT"/>underlier<br ALIGN="LEFT"/>|add_clause(name: str, clause: Clause): None<br ALIGN="LEFT"/>clauses(): Iterator[Clause]<br ALIGN="LEFT"/>delist(): None<br ALIGN="LEFT"/>get_underlier(name: str): BasePrimary<br ALIGN="LEFT"/>list(pricer: Callable[[T], Tensor], cost: float): None<br ALIGN="LEFT"/>named_clauses(): Iterator[Tuple[str, Clause]]<br ALIGN="LEFT"/>named_underliers(): Iterator[Tuple[str, BasePrimary]]<br ALIGN="LEFT"/>payoff(): Tensor<br ALIGN="LEFT"/><I>payoff_fn</I>(): Tensor<br ALIGN="LEFT"/>register_underlier(name: str, underlier: BasePrimary): None<br ALIGN="LEFT"/>simulate(n_paths: int, init_state: Optional[Tuple[TensorOrScalar, ...]]): None<br ALIGN="LEFT"/>to(): T<br ALIGN="LEFT"/>ul(index: int): BasePrimary<br ALIGN="LEFT"/>underliers(): Iterator[BasePrimary]<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.base.BaseInstrument" [color="black", fontcolor="black", label=<{BaseInstrument|cost : float<br ALIGN="LEFT"/>is_listed<br ALIGN="LEFT"/>spot<br ALIGN="LEFT"/>|bfloat16(): T<br ALIGN="LEFT"/>cpu(): T<br ALIGN="LEFT"/>cuda(device: Optional[int]): T<br ALIGN="LEFT"/>double(): T<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>float(): T<br ALIGN="LEFT"/>float16(): T<br ALIGN="LEFT"/>float32(): T<br ALIGN="LEFT"/>float64(): T<br ALIGN="LEFT"/>half(): T<br ALIGN="LEFT"/><I>simulate</I>(n_paths: int, time_horizon: float): None<br ALIGN="LEFT"/><I>to</I>(): T<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.derivative.base.BaseOption" [color="black", fontcolor="black", label=<{BaseOption|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.instruments.primary.base.BasePrimary" [color="black", fontcolor="black", label=<{BasePrimary|cost : float<br ALIGN="LEFT"/>default_init_state<br ALIGN="LEFT"/>device : Optional[torch.device]<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>dtype : Optional[torch.dtype]<br ALIGN="LEFT"/>is_listed<br ALIGN="LEFT"/>spot<br ALIGN="LEFT"/>|buffers(): Iterator[Tensor]<br ALIGN="LEFT"/>get_buffer(name: str): Tensor<br ALIGN="LEFT"/>named_buffers(): Iterator[Tuple[str, Tensor]]<br ALIGN="LEFT"/>register_buffer(name: str, tensor: Tensor): None<br ALIGN="LEFT"/><I>simulate</I>(n_paths: int, time_horizon: float, init_state: Optional[Tuple[TensorOrScalar, ...]]): None<br ALIGN="LEFT"/>to(): T<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.bs.black_scholes.BlackScholes" [color="black", fontcolor="black", label=<{BlackScholes|delta : Callable[..., Tensor]<br ALIGN="LEFT"/>gamma : Callable[..., Tensor]<br ALIGN="LEFT"/>inputs : Callable[..., List[str]]<br ALIGN="LEFT"/>price : Callable[..., Tensor]<br ALIGN="LEFT"/>theta : Callable[..., Tensor]<br ALIGN="LEFT"/>vega : Callable[..., Tensor]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.nn.modules.bs.black_scholes.BlackScholesModuleFactory" [color="black", fontcolor="black", label=<{BlackScholesModuleFactory|<br ALIGN="LEFT"/>|features(): Iterator[Type[Module]]<br ALIGN="LEFT"/>get_class(name: str): Type[Module]<br ALIGN="LEFT"/>get_class_from_derivative(derivative: Derivative): Type[Module]<br ALIGN="LEFT"/>named_modules(): Iterator[Tuple[str, Type[Module]]]<br ALIGN="LEFT"/>names(): Iterator[str]<br ALIGN="LEFT"/>register_module(name: str, cls: Type[Module]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.primary.brownian.BrownianStock" [color="black", fontcolor="black", label=<{BrownianStock|cost : float<br ALIGN="LEFT"/>default_init_state<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>mu : float<br ALIGN="LEFT"/>sigma : float<br ALIGN="LEFT"/>variance<br ALIGN="LEFT"/>volatility<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>simulate(n_paths: int, time_horizon: float, init_state: Optional[Tuple[TensorOrScalar]]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.primary.cir.CIRRate" [color="black", fontcolor="black", label=<{CIRRate|cost : float<br ALIGN="LEFT"/>default_init_state<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>kappa : float<br ALIGN="LEFT"/>sigma : float<br ALIGN="LEFT"/>theta : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>simulate(n_paths: int, time_horizon: float, init_state: Optional[Tuple[TensorOrScalar, ...]]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.clamp.Clamp" [color="black", fontcolor="black", label=<{Clamp|<br ALIGN="LEFT"/>|forward(input: Tensor, min: Optional[Tensor], max: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.derivative.base.Derivative" [color="black", fontcolor="black", label=<{Derivative|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.features.features.Empty" [color="black", fontcolor="black", label=<{Empty|name : str<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.loss.EntropicLoss" [color="black", fontcolor="black", label=<{EntropicLoss|a : float<br ALIGN="LEFT"/>|cash(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.loss.EntropicRiskMeasure" [color="black", fontcolor="black", label=<{EntropicRiskMeasure|a : float<br ALIGN="LEFT"/>|cash(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.derivative.european_binary.EuropeanBinaryOption" [color="black", fontcolor="black", label=<{EuropeanBinaryOption|call : bool<br ALIGN="LEFT"/>maturity : float<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>payoff_fn(): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.derivative.cliquet.EuropeanForwardStartOption" [color="black", fontcolor="black", label=<{EuropeanForwardStartOption|maturity : float<br ALIGN="LEFT"/>start : float<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>payoff_fn(): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.derivative.european.EuropeanOption" [color="black", fontcolor="black", label=<{EuropeanOption|call : bool<br ALIGN="LEFT"/>maturity : float<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>payoff_fn(): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.loss.ExpectedShortfall" [color="black", fontcolor="black", label=<{ExpectedShortfall|p : float<br ALIGN="LEFT"/>|cash(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.ExpiryTime" [color="black", fontcolor="black", label=<{ExpiryTime|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.features._base.Feature" [color="black", fontcolor="black", label=<{Feature|derivative<br ALIGN="LEFT"/>hedger : Optional[Module]<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>|<I>get</I>(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>is_state_dependent(): bool<br ALIGN="LEFT"/>of(derivative: BaseDerivative, hedger: Optional[Module]): T<br ALIGN="LEFT"/>register_derivative(derivative: BaseDerivative): None<br ALIGN="LEFT"/>register_hedger(hedger: Optional[Module]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features._getter.FeatureFactory" [color="black", fontcolor="black", label=<{FeatureFactory|<br ALIGN="LEFT"/>|features(): Iterator[Type[Feature]]<br ALIGN="LEFT"/>get_class(name: str): Type[Feature]<br ALIGN="LEFT"/>get_instance(name: str): Feature<br ALIGN="LEFT"/>named_features(): Iterator[Tuple[str, Type[Feature]]]<br ALIGN="LEFT"/>names(): Iterator[str]<br ALIGN="LEFT"/>register_feature(name: str, cls: Type[Feature]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.container.FeatureList" [color="black", fontcolor="black", label=<{FeatureList|features : list<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>is_state_dependent(): bool<br ALIGN="LEFT"/>of(derivative: BaseDerivative, hedger: Optional[Module]): T<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.loss.HedgeLoss" [color="black", fontcolor="black", label=<{HedgeLoss|<br ALIGN="LEFT"/>|cash(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/><I>forward</I>(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.hedger.Hedger" [color="black", fontcolor="black", label=<{Hedger|criterion<br ALIGN="LEFT"/>inputs<br ALIGN="LEFT"/>model : Module<br ALIGN="LEFT"/>|compute_hedge(derivative: BaseDerivative, hedge: Optional[List[BaseInstrument]]): Tensor<br ALIGN="LEFT"/>compute_loss(derivative: BaseDerivative, hedge: Optional[List[BaseInstrument]], n_paths: int, n_times: int, init_state: Optional[Tuple[TensorOrScalar, ...]], enable_grad: bool): Tensor<br ALIGN="LEFT"/>compute_pl(derivative: BaseDerivative, hedge: Optional[List[BaseInstrument]]): Tensor<br ALIGN="LEFT"/>compute_pnl(derivative: BaseDerivative, hedge: Optional[List[BaseInstrument]], n_paths: int, init_state: Optional[Tuple[TensorOrScalar, ...]]): Tensor<br ALIGN="LEFT"/>compute_portfolio(derivative: BaseDerivative, hedge: Optional[List[BaseInstrument]]): Tensor<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>fit(derivative: BaseDerivative, hedge: Optional[List[BaseInstrument]], n_epochs: int, n_paths: int, n_times: int, optimizer: Union[Optimizer, Callable[..., Optimizer]], init_state: Optional[Tuple[TensorOrScalar, ...]], verbose: bool, validation: bool, tqdm_kwargs: dict): Optional[List[float]]<br ALIGN="LEFT"/>forward(input: Tensor): Tensor<br ALIGN="LEFT"/>get_input(derivative: BaseDerivative, time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>price(derivative: BaseDerivative, hedge: Optional[List[BaseInstrument]], n_paths: int, n_times: int, init_state: Optional[Tuple[TensorOrScalar, ...]], enable_grad: bool): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.primary.heston.HestonStock" [color="black", fontcolor="black", label=<{HestonStock|cost : float<br ALIGN="LEFT"/>default_init_state<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>kappa : float<br ALIGN="LEFT"/>rho : float<br ALIGN="LEFT"/>sigma : float<br ALIGN="LEFT"/>spot : Tensor<br ALIGN="LEFT"/>theta : float<br ALIGN="LEFT"/>variance : Tensor<br ALIGN="LEFT"/>volatility<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>simulate(n_paths: int, time_horizon: float, init_state: Optional[Tuple[TensorOrScalar, ...]]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.base.Instrument" [color="black", fontcolor="black", label=<{Instrument|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.nn.modules.loss.IsoelasticLoss" [color="black", fontcolor="black", label=<{IsoelasticLoss|a : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.clamp.LeakyClamp" [color="black", fontcolor="black", label=<{LeakyClamp|clamped_slope : float<br ALIGN="LEFT"/>inverted_output : str<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor, min: Optional[Tensor], max: Optional[Tensor]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.primary.local_volatility.LocalVolatilityStock" [color="black", fontcolor="black", label=<{LocalVolatilityStock|cost : float<br ALIGN="LEFT"/>default_init_state<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>sigma_fn : Callable<br ALIGN="LEFT"/>spot : Tensor<br ALIGN="LEFT"/>variance<br ALIGN="LEFT"/>volatility : Tensor<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>simulate(n_paths: int, time_horizon: float, init_state: Optional[Tuple[TensorOrScalar]]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.stochastic.local_volatility.LocalVolatilityTuple" [color="black", fontcolor="black", label=<{LocalVolatilityTuple|variance<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.features.features.LogMoneyness" [color="black", fontcolor="black", label=<{LogMoneyness|derivative<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.instruments.derivative.lookback.LookbackOption" [color="black", fontcolor="black", label=<{LookbackOption|call : bool<br ALIGN="LEFT"/>maturity : float<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>payoff_fn(): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.MaxLogMoneyness" [color="black", fontcolor="black", label=<{MaxLogMoneyness|derivative<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.features.features.MaxMoneyness" [color="black", fontcolor="black", label=<{MaxMoneyness|derivative<br ALIGN="LEFT"/>log : bool<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.primary.merton_jump.MertonJumpStock" [color="black", fontcolor="black", label=<{MertonJumpStock|cost : float<br ALIGN="LEFT"/>default_init_state<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>engine : Callable[..., Tensor]<br ALIGN="LEFT"/>jump_mean : float<br ALIGN="LEFT"/>jump_per_year : float<br ALIGN="LEFT"/>jump_std : float<br ALIGN="LEFT"/>mu : float<br ALIGN="LEFT"/>sigma : float<br ALIGN="LEFT"/>spot : Tensor<br ALIGN="LEFT"/>variance<br ALIGN="LEFT"/>volatility<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>simulate(n_paths: int, time_horizon: float, init_state: Optional[Tuple[TensorOrScalar, ...]]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.container.ModuleOutput" [color="black", fontcolor="black", label=<{ModuleOutput|inputs<br ALIGN="LEFT"/>module : Module<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor): Tensor<br ALIGN="LEFT"/>get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>is_state_dependent(): bool<br ALIGN="LEFT"/>of(derivative: BaseDerivative, hedger: Optional[Module]): TM<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.Moneyness" [color="black", fontcolor="black", label=<{Moneyness|derivative<br ALIGN="LEFT"/>log : bool<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.mlp.MultiLayerPerceptron" [color="black", fontcolor="black", label=<{MultiLayerPerceptron|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.nn.modules.naked.Naked" [color="black", fontcolor="black", label=<{Naked|out_features : int<br ALIGN="LEFT"/>|forward(input: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.loss.OCE" [color="black", fontcolor="black", label=<{OCE|utility : Callable[[Tensor], Tensor]<br ALIGN="LEFT"/>w : Parameter<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.Ones" [color="black", fontcolor="black", label=<{Ones|name : str<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.derivative.base.OptionMixin" [color="black", fontcolor="black", label=<{OptionMixin|maturity : float<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>underlier<br ALIGN="LEFT"/>|log_moneyness(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>max_log_moneyness(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>max_moneyness(time_step: Optional[int], log: bool): Tensor<br ALIGN="LEFT"/>moneyness(time_step: Optional[int], log: bool): Tensor<br ALIGN="LEFT"/>time_to_maturity(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.OptionType" [color="black", fontcolor="black", label=<{OptionType|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.features.features.PrevHedge" [color="black", fontcolor="black", label=<{PrevHedge|hedger : Module<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.primary.base.Primary" [color="black", fontcolor="black", label=<{Primary|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.nn.modules.loss.QuadraticCVaR" [color="black", fontcolor="black", label=<{QuadraticCVaR|lam : float<br ALIGN="LEFT"/>|cash(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor, target: TensorOrScalar): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.stochastic.engine.RandnSobolBoxMuller" [color="black", fontcolor="black", label=<{RandnSobolBoxMuller|scramble : bool<br ALIGN="LEFT"/>seed : Optional[int]<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.instruments.primary.rough_bergomi.RoughBergomiStock" [color="black", fontcolor="black", label=<{RoughBergomiStock|alpha : float<br ALIGN="LEFT"/>cost : float<br ALIGN="LEFT"/>default_init_state<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>eta : float<br ALIGN="LEFT"/>rho : float<br ALIGN="LEFT"/>spot : Tensor<br ALIGN="LEFT"/>variance : Tensor<br ALIGN="LEFT"/>volatility<br ALIGN="LEFT"/>xi : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>simulate(n_paths: int, time_horizon: float, init_state: Optional[Tuple[TensorOrScalar, ...]]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.svi.SVIVariance" [color="black", fontcolor="black", label=<{SVIVariance|a : Union<br ALIGN="LEFT"/>b : Union<br ALIGN="LEFT"/>m : Union<br ALIGN="LEFT"/>rho : Union<br ALIGN="LEFT"/>sigma : Union<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.Spot" [color="black", fontcolor="black", label=<{Spot|log : bool<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.stochastic.heston.SpotVarianceTuple" [color="black", fontcolor="black", label=<{SpotVarianceTuple|volatility<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.features._base.StateIndependentFeature" [color="black", fontcolor="black", label=<{StateIndependentFeature|derivative<br ALIGN="LEFT"/>hedger : NoneType<br ALIGN="LEFT"/>|of(derivative: BaseDerivative, hedger: Optional[Module]): 'StateIndependentFeature'<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.TimeToMaturity" [color="black", fontcolor="black", label=<{TimeToMaturity|derivative<br ALIGN="LEFT"/>name : str<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.UnderlierLogSpot" [color="black", fontcolor="black", label=<{UnderlierLogSpot|<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"pfhedge.features.features.UnderlierSpot" [color="black", fontcolor="black", label=<{UnderlierSpot|log : bool<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.Variance" [color="black", fontcolor="black", label=<{Variance|name : str<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.derivative.variance_swap.VarianceSwap" [color="black", fontcolor="black", label=<{VarianceSwap|maturity : float<br ALIGN="LEFT"/>strike : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>payoff_fn(): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.instruments.primary.vasicek.VasicekRate" [color="black", fontcolor="black", label=<{VasicekRate|cost : float<br ALIGN="LEFT"/>default_init_state<br ALIGN="LEFT"/>dt : float<br ALIGN="LEFT"/>kappa : float<br ALIGN="LEFT"/>sigma : float<br ALIGN="LEFT"/>theta : float<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>simulate(n_paths: int, time_horizon: float, init_state: Optional[Tuple[TensorOrScalar, ...]]): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.Volatility" [color="black", fontcolor="black", label=<{Volatility|name : str<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.nn.modules.ww.WhalleyWilmott" [color="black", fontcolor="black", label=<{WhalleyWilmott|a : float<br ALIGN="LEFT"/>bs<br ALIGN="LEFT"/>derivative<br ALIGN="LEFT"/>|extra_repr(): str<br ALIGN="LEFT"/>forward(input: Tensor): Tensor<br ALIGN="LEFT"/>inputs(): List[str]<br ALIGN="LEFT"/>width(input: Tensor): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features.features.Zeros" [color="black", fontcolor="black", label=<{Zeros|name : str<br ALIGN="LEFT"/>|get(time_step: Optional[int]): Tensor<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"pfhedge.features._base.StateIndependentFeature" -> "pfhedge.features._base.Feature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.container.FeatureList" -> "pfhedge.features._base.Feature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.container.ModuleOutput" -> "pfhedge.features._base.Feature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.Barrier" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.Empty" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.ExpiryTime" -> "pfhedge.features.features.TimeToMaturity" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.LogMoneyness" -> "pfhedge.features.features.Moneyness" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.MaxLogMoneyness" -> "pfhedge.features.features.MaxMoneyness" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.MaxMoneyness" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.Moneyness" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.Ones" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.OptionType" -> "pfhedge.instruments.derivative.base.BaseDerivative" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.OptionType" -> "pfhedge.instruments.derivative.base.OptionMixin" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.PrevHedge" -> "pfhedge.features._base.Feature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.Spot" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.TimeToMaturity" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.UnderlierLogSpot" -> "pfhedge.features.features.UnderlierSpot" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.UnderlierSpot" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.Variance" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.Volatility" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.features.Zeros" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.base.Instrument" -> "pfhedge.instruments.base.BaseInstrument" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.american_binary.AmericanBinaryOption" -> "pfhedge.instruments.derivative.base.BaseDerivative" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.american_binary.AmericanBinaryOption" -> "pfhedge.instruments.derivative.base.OptionMixin" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.base.BaseDerivative" -> "pfhedge.instruments.base.BaseInstrument" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.base.BaseOption" -> "pfhedge.instruments.derivative.base.BaseDerivative" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.base.BaseOption" -> "pfhedge.instruments.derivative.base.OptionMixin" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.base.Derivative" -> "pfhedge.instruments.derivative.base.BaseDerivative" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.cliquet.EuropeanForwardStartOption" -> "pfhedge.instruments.derivative.base.BaseDerivative" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.european.EuropeanOption" -> "pfhedge.instruments.derivative.base.BaseDerivative" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.european.EuropeanOption" -> "pfhedge.instruments.derivative.base.OptionMixin" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.european_binary.EuropeanBinaryOption" -> "pfhedge.instruments.derivative.base.BaseDerivative" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.european_binary.EuropeanBinaryOption" -> "pfhedge.instruments.derivative.base.OptionMixin" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.lookback.LookbackOption" -> "pfhedge.instruments.derivative.base.BaseDerivative" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.lookback.LookbackOption" -> "pfhedge.instruments.derivative.base.OptionMixin" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.derivative.variance_swap.VarianceSwap" -> "pfhedge.instruments.derivative.base.BaseDerivative" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.primary.base.BasePrimary" -> "pfhedge.instruments.base.BaseInstrument" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.primary.base.Primary" -> "pfhedge.instruments.primary.base.BasePrimary" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.primary.brownian.BrownianStock" -> "pfhedge.instruments.primary.base.BasePrimary" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.primary.cir.CIRRate" -> "pfhedge.instruments.primary.base.BasePrimary" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.primary.heston.HestonStock" -> "pfhedge.instruments.primary.base.BasePrimary" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.primary.local_volatility.LocalVolatilityStock" -> "pfhedge.instruments.primary.base.BasePrimary" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.primary.merton_jump.MertonJumpStock" -> "pfhedge.instruments.primary.base.BasePrimary" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.primary.rough_bergomi.RoughBergomiStock" -> "pfhedge.instruments.primary.base.BasePrimary" [arrowhead="empty", arrowtail="none"];
"pfhedge.instruments.primary.vasicek.VasicekRate" -> "pfhedge.instruments.primary.base.BasePrimary" [arrowhead="empty", arrowtail="none"];
"pfhedge.nn.modules.bs.american_binary.BSAmericanBinaryOption" -> "pfhedge.nn.modules.bs._base.BSModuleMixin" [arrowhead="empty", arrowtail="none"];
"pfhedge.nn.modules.bs.european.BSEuropeanOption" -> "pfhedge.nn.modules.bs._base.BSModuleMixin" [arrowhead="empty", arrowtail="none"];
"pfhedge.nn.modules.bs.european_binary.BSEuropeanBinaryOption" -> "pfhedge.nn.modules.bs._base.BSModuleMixin" [arrowhead="empty", arrowtail="none"];
"pfhedge.nn.modules.bs.lookback.BSLookbackOption" -> "pfhedge.nn.modules.bs._base.BSModuleMixin" [arrowhead="empty", arrowtail="none"];
"pfhedge.nn.modules.loss.EntropicLoss" -> "pfhedge.nn.modules.loss.HedgeLoss" [arrowhead="empty", arrowtail="none"];
"pfhedge.nn.modules.loss.EntropicRiskMeasure" -> "pfhedge.nn.modules.loss.HedgeLoss" [arrowhead="empty", arrowtail="none"];
"pfhedge.nn.modules.loss.ExpectedShortfall" -> "pfhedge.nn.modules.loss.HedgeLoss" [arrowhead="empty", arrowtail="none"];
"pfhedge.nn.modules.loss.IsoelasticLoss" -> "pfhedge.nn.modules.loss.HedgeLoss" [arrowhead="empty", arrowtail="none"];
"pfhedge.nn.modules.loss.OCE" -> "pfhedge.nn.modules.loss.HedgeLoss" [arrowhead="empty", arrowtail="none"];
"pfhedge.nn.modules.loss.QuadraticCVaR" -> "pfhedge.nn.modules.loss.HedgeLoss" [arrowhead="empty", arrowtail="none"];
"pfhedge.features.container.FeatureList" -> "pfhedge.features.container.ModuleOutput" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="inputs", style="solid"];
"pfhedge.features.container.FeatureList" -> "pfhedge.nn.modules.hedger.Hedger" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="inputs", style="solid"];
"pfhedge.features.features.OptionType" -> "pfhedge.features.features.LogMoneyness" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="derivative", style="solid"];
"pfhedge.features.features.OptionType" -> "pfhedge.features.features.MaxLogMoneyness" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="derivative", style="solid"];
"pfhedge.features.features.OptionType" -> "pfhedge.features.features.MaxMoneyness" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="derivative", style="solid"];
"pfhedge.features.features.OptionType" -> "pfhedge.features.features.Moneyness" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="derivative", style="solid"];
"pfhedge.features.features.OptionType" -> "pfhedge.features.features.TimeToMaturity" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="derivative", style="solid"];
"pfhedge.instruments.derivative.base.BaseDerivative" -> "pfhedge.features._base.Feature" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="derivative", style="solid"];
"pfhedge.instruments.derivative.base.BaseDerivative" -> "pfhedge.features._base.StateIndependentFeature" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="derivative", style="solid"];
"pfhedge.instruments.primary.base.BasePrimary" -> "pfhedge.instruments.derivative.base.BaseDerivative" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="underlier", style="solid"];
"pfhedge.instruments.primary.base.BasePrimary" -> "pfhedge.instruments.derivative.base.OptionMixin" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="underlier", style="solid"];
"pfhedge.nn.modules.bs.black_scholes.BlackScholes" -> "pfhedge.nn.modules.ww.WhalleyWilmott" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="bs", style="solid"];
"pfhedge.instruments.derivative.base.Derivative" -> "pfhedge.nn.modules.ww.WhalleyWilmott" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="derivative", style="solid"];
"pfhedge.nn.modules.loss.HedgeLoss" -> "pfhedge.nn.modules.hedger.Hedger" [arrowhead="odiamond", arrowtail="none", fontcolor="green", label="criterion", style="solid"];
}
